		push 400
		pop vbp			; clear screen

		push 0
		pop rax			; rax = 0

row_loop_start:	push rax
		push 40
		jge row_loop_end	; if (rax >= 40) break

		push 0
		pop rbx			; rbx = 0

col_loop_start:	push rbx
		push 100
		jge col_loop_end	; if (rbx >= 100) break

		push rax
		push 100
		mul
		push rbx
		add
		pop rdx			; rdx = 100*rax + rbx

		call on_circle

		pop [rdx]

		push rbx
		inc
		pop rbx			; increment column number
		
		jmp col_loop_start

col_loop_end:	push rax
		inc
		pop rax			; increment row number
		
		jmp row_loop_start

row_loop_end:	push 0
		pop vbp			; display buffer

		halt



on_circle:	push rax
		push 20
		sub
		push rax
		push 20
		sub
		mul			; y^2
		push 11
		mul			; 11y^2

		push rbx
		push 50
		sub
		push rbx
		push 50
		sub
		mul			; x^2
		push 3			; 3x^2
		mul

		add			; 3x^2 + 11y^2

		push 30
		dup
		mul
		push 3
		mul			; 3 * 30^2
		jle c_true

		push 0			; 3x^2 + 11y^2 > 3 * 30^2
		ret
	
	c_true:	push 1			; 3x^2 + 11y^2 <= 3 * 30^2
		ret

